# .bashrc

# Shell variables 
export PAGER=less
export EDITOR=vim
export CLICOLOR=1
export LSCOLORS=exfxcxdxbxegedabagacad
export DEV=$HOME/Documents/Code
export GOPATH=$DEV/Go
export GOBIN=$GOPATH/bin
export PLATFORMTOOLS=$HOME/Library/Android/sdk/platform-tools
export ANDROIDTOOLS=$HOME/Library/Android/sdk/tools
export PATH=$PATH:/usr/local/sbin:$HOME/.bin:$GOBIN:$ANDROIDTOOLS:$PLATFORMTOOLS

# Attach .bash_aliases 
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# Attach .bash_variables
if [ -f ~/.bash_variables ]; then
    . ~/.bash_variables
fi

# Interactive mode check 
case $- in
    *i*) ;;
      *) return;;
esac

# Set Autocomplete Case Sensitivity 
bind 'set completion-ignore-case on'

## GIT
if [ -f /Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash ] ; then
  . /Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash
fi

## HOMEBREW
if [ -f /usr/local/Library/Contributions/brew_bash_completion.sh ] ; then
  . /usr/local/Library/Contributions/brew_bash_completion.sh
fi

## NPM
if [ -f /usr/local/etc/bash_completion.d/npm ] ; then
  . /usr/local/etc/bash_completion.d/npm
fi

# Set PS1 
## Functions
### Parse git branch
function git-branch-name {
  git symbolic-ref HEAD 2>/dev/null | cut -d"/" -f 3
}

### Check if repo is clean/dirty
function git-dirty {
  if [[ $(git status 2>/dev/null | tail -n1) != "nothing to commit, working directory clean" ]]; then
    echo "$undred"
  else
    echo "$undgrn"
  fi
}

### If in a repo, print to PS1
function git-branch-prompt {
  local branch=`git-branch-name`
  if [ $branch ]; then printf "[$(git-dirty)%s$txtrst] " $branch; fi
}

## Configure prompt
export PS1="\$(git-branch-prompt)> "

# History Settings 
## Ignore duplicates
HISTCONTROL=ignoreboth
HISTIGNORE="ls:pwd"

## Append to history file, don't overwrite
shopt -s histappend

## Set max number of history lines, and filesize
HISTSIZE=1000
HISTFILESIZE=2000

# Check window size after each command 
shopt -s checkwinsize
